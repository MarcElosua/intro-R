---
title: "Day-4: Single Cell Analysis with Bioconductor"
author: "Marc Elosua-Bay√©s"
date: "3/15/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction
In this Rmd we are going to learn what is the structure of the SingleCellExperient object, how to access it and hopefully run QC on PBMC data. We are using [OSCA](http://bioconductor.org/books/3.13/OSCA/) as the backbone of these sessions, we can't go in depth in all the steps but feel free to read each chapter of the book in detail for each step as you analyze your data. You can find a workflow analyzing this dataset [here](http://bioconductor.org/books/3.13/OSCA.workflows/unfiltered-human-pbmcs-10x-genomics.html).

## Libraries
```{r libraries}
library(tidyverse)
# install.packages("patchwork")
library(patchwork)
# install.packages("BiocManager")
# BiocManager::install(pkgs = c("SingleCellExperiment", "DropletUtils", "scran", "scater", "scuttle", "uwot", "rtracklayer"))
library(SingleCellExperiment)
library(DropletUtils)
library(scran)
library(scater)
```

## Load data
The data we are going to use was generated by 10X genomics and consists of ~3k PBMCs. It can be downloaded from the 10X [website](https://support.10xgenomics.com/single-cell-gene-expression/datasets/2.1.0/pbmc4k?) and you can find it in the folder *data-day4*.
```{r load}
path <- "data-day4/filtered_gene_bc_matrices"
sce <- read10xCounts(
    sample = path,
    col.names = TRUE,
    sample.names = "pbmc")
```

## SCE structure
More details can be found [here](http://bioconductor.org/books/3.13/OSCA.intro/).
```{r sce}
sce
# class: SingleCellExperiment 
# dim: 33694 4340 
# metadata(1): Samples
# assays(1): counts
# rownames(33694): ENSG00000243485 ENSG00000237613
#   ... ENSG00000277475 ENSG00000268674
# rowData names(2): ID Symbol
# colnames(4340): AAACCTGAGAAGGCCT-1
#   AAACCTGAGACAGACC-1 ... TTTGTCAGTTAAGACA-1
#   TTTGTCATCCCAAGAT-1
# colData names(2): Sample Barcode
# reducedDimNames(0):
# mainExpName: NULL
# altExpNames(0):
```

How can we access the different data structures
```{r}
# Access the count nad logcount matrix, show the first 5 rows and column
counts(sce)[1:5, 1:5]
logcounts(sce)[1:5, 1:5]

# Access the information for each cell
colData(sce)

# Access information for each gene
rowData(sce)

# Change gene names to symbol 
rownames(sce) <- rowData(sce)$Symbol
# See how the rownames have changed
sce
```

How can we subset a `SingleCellExperiment`?
```{r}
# Select specific cells
sce[, 1:1000]

# Select specific genes
sce[1:1000, ]

gene_ls <- c("CD3D", "CD4", "CD8", "CCR7", "CLEC9A", "IRF8")
sce[gene_ls, ]

# Subset for both
sce_sub <- sce[1:1000, 1:1000]
sce_sub
```

## QC

Now that we know how the `SingleCellExperiment` works we can start looking at our data and making some plots :))
You can look at the [QC chapter](http://bioconductor.org/books/3.13/OSCA.basic/quality-control.html) in the OSCA book for more info!

The first step is to compute basic QC metrics - 
* sum: total number of UMIs detected
* detected: total number of genes detected
* subsets_mito_pct_percent: mitochondrial %
* subsets_ribo_pct_percent: ribosomal %

```{r}
is.mito <- str_detect(rownames(sce), "^MT")
is.ribo <- str_detect(rownames(sce), "^RPS|^RPL]")

df <- perCellQCMetrics(
    sce,
    subsets = list(
        mito_pct = is.mito,
        ribo_pct = is.ribo))

colData(sce) <- cbind(colData(sce), df)
```

Lets visualize QC markers with violin plots data 
```{r fig.width=12, fig.height=12}
lapply(c("sum", "detected", "subsets_mito_pct_percent", "subsets_ribo_pct_percent"),
    function(i) {
        plotColData(
            sce,
            y = i,
            colour_by = "Sample") +
            # scale_y_log10() +
            ggtitle(i)
        }) %>% wrap_plots()
```

Now we can look at how these metric co-vary together

When we plot the number of genes detected per cell as a function of number of UMIswe should see a linear relation in the log scale.
```{r}
(p1 <- plotColData(
    sce,
    x = "sum",
    y = "detected",
    colour_by = "subsets_mito_pct_percent") +
    # scale_y_log10() +
    # scale_x_log10() +
    ggtitle("nUMI vs nGenes"))
```

Furthermore we can also check if there are cells that have low number of genes detected paired with high mitochondrial % indicating the cell has lysed during the process. Cells that are found at the top left corner have low number of genes with high Mito % so we can consider removing them... *UNLESS* there is a specific population that we expect to have these characteristics!
```{r}
(p2 <- plotColData(
    sce,
    x = "detected",
    y = "subsets_mito_pct_percent",
    colour_by = "subsets_mito_pct_percent") +
    scale_x_log10() +
    ggtitle("nGenes vs Mito %"))
```

## Remove lowQ cells
Set thresholds to remove
```{r}
mito <- 12.5
umi <- 1000
feat <- 500
```

Look at which cells we would be removing here
```{r}
p1 +
    geom_vline(xintercept = umi, color = "red", linetype = "dashed") +
    geom_hline(yintercept = feat, color = "purple", linetype = "dotted")

p2 +
    geom_hline(yintercept = mito, color = "red", linetype = "dashed") +
    geom_vline(xintercept = feat, color = "purple", linetype = "dotted")
```

We can add a column indicating if the cell is good vs bad quality
```{r}
sce$keep <- sce$subsets_mito_pct_percent < mito & sce$sum > umi & sce$detected > feat
(tt <- table(sce$keep))
```

We are discarding a total of `r tt[1]` cells

Diagnosing cell type loss
```{r}
# Using the non-batched 'discard' vector for demonstration purposes,
# as it has more cells for stable calculation of 'lost'.
lost <- calculateAverage(counts(sce)[, !sce$keep])
kept <- calculateAverage(counts(sce)[, sce$keep])

library(edgeR)
logged <- cpm(cbind(lost, kept), log=TRUE, prior.count=2)
logFC <- logged[,1] - logged[,2]
abundance <- rowMeans(logged)
```

If the discarded pool is enriched for a certain cell type, we should observe increased expression of the corresponding marker genes. 

```{r}
ggplot() +
    geom_point(aes(x = abundance, y = logFC, color = is.mito | is.ribo)) +
    labs(
        x = "Average count",
        y = "Log-FC (lost/kept)",
        color = "Ribo or Mito gene") +
    geom_hline(yintercept = 1, color = "red", linetype = "dashed") +
    geom_hline(yintercept = -1, color = "red", linetype = "dashed") +
    scale_color_brewer(palette = "Set2", direction = -1) +
    theme_classic()
```

We can see how the genes that have major logFC changes are either ribosomal or mitochondrial so we can be confident that at this point we are not removing a biological population.

## Normalization & Dim reduction
Lastly we are going to visualize where these cells fall on the UMAP. In order to do this we need to do a couple of processing steps that we will go a bit deeper into next week so just believe me until then.

```{r}
sce <- logNormCounts(sce)
dec <- modelGeneVar(sce)
# Extract metadata from S4 object
fit <- metadata(dec)
# Chech that the Gene variance modeling hasn't yielded an overfitted trend when there is a few high abundance genes that are higly variable
plot(fit$mean, fit$var,
    xlab = "Mean of log-expression",
    ylab = "Variance of log-expression") 
curve(fit$trend(x), col = "dodgerblue", add = TRUE, lwd = 2)
```

```{r}
sce <- runPCA(sce, subset_row = getTopHVGs(dec, n = 5000, fdr.threshold = 0.05))
# Percentage of variance explained is tucked away in the attributes.
percent.var <- attr(reducedDim(sce), "percentVar")
ggplot() +
    geom_point(aes(x = seq_len(length(percent.var)), y = percent.var)) +
    labs(x = "PC", y = "Variance explained (%)") +
    theme_classic()
```

It seems like the 1st PC explains 40% of the variability in the data, we can take a look at which genes are driving this:
```{r}
pca <- reducedDim(sce, "PCA")
# Extract the weights for each gene for each PC
pca_weights <- attr(pca, "rotation")

# Look at the genes corresponding to the top PC
sort(pca_weights[, "PC1"], decreasing = TRUE)[1:10]
sort(pca_weights[, "PC2"], decreasing = TRUE)[1:10]
sort(pca_weights[, "PC3"], decreasing = TRUE)[1:20]
sort(pca_weights[, "PC4"], decreasing = TRUE)[1:10]
sort(pca_weights[, "PC5"], decreasing = TRUE)[1:10]
```

Run UMAP on the using the first 20 PC
```{r}
sce <- runUMAP(
    sce,
    dimred = "PCA",
    ncomponents = 3,
    pca = 20)
```

Look at the cells on the UMAP
```{r}
plotUMAP(sce, colour_by = "keep") +
    scale_color_manual(values = c("red", "grey")) +
    labs("UMAP by keep")
```

## Session Info
```{r}
sessionInfo()
```

